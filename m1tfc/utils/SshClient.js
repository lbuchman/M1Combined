'use strict';

const { NodeSSH } = require('node-ssh');
const fs = require('fs-extra');
const delay = require('delay');
/**
 * @class
 * An SSH client wrapper.
 */
class SshClient {
    /**
     * @constructor
     * @param {string} address The IP address.
     * @param {string} idRsa The SSH key.
     */
    constructor(address, idRsa) {
        const [addr, port] = address.split(':');
        this.ssh = new NodeSSH();
        this.address = addr;
        this.port = parseInt(port || '22', 10);
        this.idRsa = idRsa;
    }

    /**
     * @public
     * set rsa key
     */
    async reConnect(username, password, idRsa, timeout) {
        if (idRsa) {
            this.idRsa = idRsa;
        }
        if (timeout - new Date() / 1000 > 0) {
            try {
                await this.connect(username, password);
                return;
            }
            catch (err) {
                await delay(2000);
            }
            await this.reConnect(username, password, idRsa, timeout);
            return;
        }

        throw new Error('ssh reconnect failed');
    }

    /**
     * @public
     * Connects to the remote machine.
     */
    async connect(username, password, timeout = 10000) {
        const opt = { host: this.address, port: this.port, username };
        if (this.idRsa) {
            opt.privateKey = this.idRsa;
        }
        else {
            opt.password = password;
        }
        this.host = this.address;
        return new Promise(async (resolve, reject) => {
            const timeoutHandle = setTimeout(() => {
                reject(new Error('ssh connect timeout'));
            }, timeout);
            try {
                await this.ssh.connect(opt);
            }
            catch (err) {
                reject(err);
                clearTimeout(timeoutHandle);
                return;
            }
            clearTimeout(timeoutHandle);
            resolve();
        });
    }

    /**
     * @public
     * @param {object} ssh The SSH context.
     * @param {string} command The command to execute.
     * @returns {string} The standard output generated by the remote command.
     */
    execCommand(command, nothrow = false) {
        return this.ssh.execCommand(command)
        .then((result) => {
            if (result.code) {
                throw new Error(`Command "${command}" failed. Error: ${result.stderr}`);
            }
            return result.stdout;
        })
        .catch((err) => {
            if (!nothrow) throw (err);
        });
    }

    /**
     * @public
     * Sends a file from the local machine to the remote machine.
     * @param {string} localFile The local file path.
     * @param {string} remoteFile The remote file path.
     */
    putFile(localFile, remoteFile) {
        return this.ssh.putFile(localFile, remoteFile);
    }

    /**
     * @public
     * Receives file to the local machine from the remote machine.
     * @param {string} localFile The local file path.
     * @param {string} remoteFile The remote file path.
     */
    getFile(localFile, remoteFile) {
        return this.ssh.getFile(localFile, remoteFile);
    }

    /**
     * @public
     * Receives file to the local machine from the remote machine.
     * @param {string} localFile The local file path.
     * @param {string} remoteFile The remote file path.
     */
    getFileWithData(localFile, remoteFile) {
        return this.ssh.getFile(localFile, remoteFile)
        .then(() => {
            return fs.readFileSync(localFile);
        });
    }

    /**
     * @public
     * Deletes a file from the remote machine.
     * @param {string} remoteFile The file to delete.
     */
    deleteFile(remoteFile) {
        return this.execCommand(`rm ${remoteFile} || echo ''`);
    }

    /**
     * @public
     * Disconnects from the remote machine.
     */
    disconnect() {
        return this.ssh.dispose();
    }
}

module.exports = SshClient;
