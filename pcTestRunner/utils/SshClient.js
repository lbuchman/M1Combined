'use strict';

const { NodeSSH } = require('node-ssh');
const fs = require('fs-extra');

/**
 * @class
 * An SSH client wrapper.
 */
class SshClient {
    /**
     * @constructor
     * @param {string} address The IP address.
     * @param {string} idRsa The SSH key.
     */
    constructor(address, idRsa) {
        const [addr, port] = address.split(':');
        this.ssh = new NodeSSH();
        this.address = addr;
        this.port = parseInt(port || '22', 10);
        this.idRsa = idRsa;
    }

    /**
     * @public
     * set rsa key
     */
    reConnect(username, password, idRsa, timeout) {
        if (idRsa) {
            this.idRsa = idRsa;
        }
        const interval = 30000;
        let count = timeout / interval;
        return new Promise((resolve, reject) => {
            const intervalTimer = setInterval(() => {
                this.connect(username, password)
                .then((ret) => {
                    resolve(ret);
                    clearInterval(intervalTimer);
                })
                .catch((err) => {
                    count -= 1;
                    if (count === 0) {
                        reject(err);
                        clearInterval(intervalTimer);
                    }
                });
            }, interval);
        });
    }

    /**
     * @public
     * Connects to the remote machine.
     */
    connect(username, password) {
        const opt = { host: this.address, port: this.port, username };
        if (this.idRsa) {
            opt.privateKey = this.idRsa;
        }
        else {
            opt.password = password;
        }
        this.host = this.address;
        return this.ssh.connect(opt);
    }

    /**
     * @public
     * @param {object} ssh The SSH context.
     * @param {string} command The command to execute.
     * @returns {string} The standard output generated by the remote command.
     */
    execCommand(command) {
        return this.ssh.execCommand(command)
        .then((result) => {
            if (result.code) {
                throw new Error(`Command "${command}" failed. Error: ${result.stderr}`);
            }
            return result.stdout;
        })
        .catch((err) => {
            throw (err);
        });
    }

    /**
     * @public
     * Sends a file from the local machine to the remote machine.
     * @param {string} localFile The local file path.
     * @param {string} remoteFile The remote file path.
     */
    putFile(localFile, remoteFile) {
        return this.ssh.putFile(localFile, remoteFile);
    }

    /**
     * @public
     * Receives file to the local machine from the remote machine.
     * @param {string} localFile The local file path.
     * @param {string} remoteFile The remote file path.
     */
    getFile(localFile, remoteFile) {
        return this.ssh.getFile(localFile, remoteFile);
    }

    /**
     * @public
     * Receives file to the local machine from the remote machine.
     * @param {string} localFile The local file path.
     * @param {string} remoteFile The remote file path.
     */
    getFileWithData(localFile, remoteFile) {
        return this.ssh.getFile(localFile, remoteFile)
        .then(() => {
            return fs.readFileSync(localFile);
        });
    }

    /**
     * @public
     * Deletes a file from the remote machine.
     * @param {string} remoteFile The file to delete.
     */
    deleteFile(remoteFile) {
        return this.execCommand(`sudo rm ${remoteFile} || echo ''`);
    }

    /**
     * @public
     * Disconnects from the remote machine.
     */
    disconnect() {
        return this.ssh.dispose();
    }
}

module.exports = SshClient;
